type: edu
files:
- name: src/tracker/Main.java
  visible: true
  text: |
    package tracker;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
  learner_created: false
- name: test/tracker/SampleTest.java
  visible: true
  text: |
    package tracker;

    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.params.ParameterizedTest;
    import org.junit.jupiter.params.provider.Arguments;
    import org.junit.jupiter.params.provider.MethodSource;
    import tracker.util.TrackerValidator;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;
    import static org.junit.jupiter.params.provider.Arguments.arguments;

    public class SampleTest {

        @Test
        void test() {
            assertEquals(5, 2 + 3);
        }

        @ParameterizedTest(name = "Should validate {0} as {1}")
        @MethodSource("pointsArgument")
        void validatePoints(String input, boolean valid) {
            assertEquals(valid, TrackerValidator.valid(input));
        }

        static List<Arguments> pointsArgument() {
            return List.of(arguments("1000 10 10 5 8", true),
                    arguments("10001 10 10 5 8", true),
                    arguments("10001 5 8 7 3", true),
                    arguments("10000 7 7 7 7 7", false),
                    arguments("10000 ? 1 1 1", false)
            );
        }
    }
  learner_created: false
- name: build.gradle
  visible: true
  text: |
    repositories {
        mavenCentral()
    }

    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
        testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.7.1'
    }

    test {
        useJUnitPlatform()
    }
  learner_created: false
- name: test/LearningProgressTrackerTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Random;
    import java.util.Set;
    import java.util.function.Predicate;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;
    import java.util.stream.Stream;

    import static org.hyperskill.hstest.testing.expect.Expectation.expect;

    public class LearningProgressTrackerTest extends StageTest<String> {
        private static final Random rnd = new Random();

        @DynamicTest(order = 1)
        CheckResult testStartAndExit() {
            TestedProgram main = new TestedProgram();
            String output = main.start();
            expect(output).toContain(1).lines();
            if (incorrectString(output, "Learning Progress Tracker")) {
                return CheckResult.wrong("When started, your program " +
                        "should print \"Learning Progress Tracker\"");
            }

            if (!main.isWaitingInput()) {
                return CheckResult.wrong("After the start, your program should " +
                        "be ready to accept commands from the user");
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 2, data = "getBlankInput")
        CheckResult testBlankInput(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (incorrectString(output, "no input")) {
                return CheckResult.wrong("When the user enters an empty or blank " +
                        "string, your program should print \"No input.\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 3, data = "getUnknownCommands")
        CheckResult testUnknownCommands(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "unknown", "command")) {
                return CheckResult.wrong("When an unknown command is entered, your " +
                        "program should display an error message: \"Unknown command!\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 4)
        CheckResult testAddStudents1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add students");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output,
                    "enter", "student", "credentials", "back", "return")) {
                return CheckResult.wrong("When 'add students' command is entered, your " +
                        "program should display the prompt \"Enter student credentials or " +
                        "'back' to return:\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "incorrect", "credentials")) {
                return CheckResult.wrong("Expected output: \"Incorrect credentials.\", " +
                        "but your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student credentials");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 5)
        CheckResult testAddStudents2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            for (String input : getCorrectCredentials()) {
                String output = main.execute(input);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "10", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 10 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult testAddStudents3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            for (String[] args : getIncorrectCredentials()) {
                String output = main.execute(args[0]);
                expect(output).toContain(1).lines();
                if (incorrectString(output, args[1])) {
                    return CheckResult.wrong("Expected output: \"" + args[1] + "\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 7)
        CheckResult testFindAll1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");
            main.execute("back");

            String output = main.execute("list");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "no", "found")) {
                return CheckResult.wrong("Expected: \"No students found.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 8)
        CheckResult testAddDoubles() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }

                output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "this", "email", "already", "taken")) {
                    return CheckResult.wrong("Expected output: \"This email is already taken.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 9)
        CheckResult testFindAll2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    main.stop();
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("list");
            List<String> lines = expect(output).toContain(credentials.size() + 1).lines();
            if (!lines.get(0).toLowerCase().contains("students")) {
                return CheckResult.wrong("Expected the header \"Students:\" but your first line was: " + lines.get(0));
            }

            List<String> ids = parseIds(lines);
            Set<String> uniqueIds = new HashSet<>(ids);
            if (uniqueIds.size() != ids.size()) {
                return CheckResult.wrong("Expected " + ids.size() +
                        " unique IDs but found only " + uniqueIds.size());
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 10)
        CheckResult testBackFromAddPoints() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add points");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "enter", "id", "points", "back", "return")) {
                return CheckResult.wrong("When 'add points' command is entered, your program should print " +
                        "\"Enter an id and points or 'back' to return:\" but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id and points");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 11)
        CheckResult testStudentPoints1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getIncorrectPoints();
            for (String point : points) {
                output = main.execute(ids.get(0) + " " + point);
                expect(output).toContain().lines();
                if (anyMissingKeywords(output, "incorrect", "format")) {
                    return CheckResult.wrong("Expected output: \"Incorrect points format.\", but your output was: " + output);
                }
            }

            output = main.execute("imsurethereisnosuchstudentid 1 1 1 1");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "no", "student", "found") ||
                    !output.contains("imsurethereisnosuchstudentid")) {
                return CheckResult.wrong("Expected output was: \"No student is found " +
                        "for id=imsurethereisnosuchstudentid.\" but your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 12)
        CheckResult testStudentPoints2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getCorrectPoints(6);

            for (int i = 0; i < points.length; i++) {
                output = main.execute(ids.get(i) + " " + points[i]);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "points", "updated")) {
                    return CheckResult.wrong("Expected \"Points updated.\" but your output was " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 13)
        CheckResult testBackFromFind() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 14)
        CheckResult testFindByID() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(5);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (int i = 0; i < ids.size(); i++) {
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
            }

            main.execute("back");
            output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            for (int i = 0; i < ids.size(); i++) {
                output = main.execute(ids.get(i));
                expect(output).toContain(1).lines();
                String expected = String.format(
                        "%s points: Java=%d; DSA=%d; Databases=%d; Spring=%d",
                        ids.get(i), i * 2, i * 2, i * 2, i * 2
                );
                if (incorrectString(output, expected)) {
                    return CheckResult.wrong("Expected output: " + expected +
                            ", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 15)
        CheckResult testBackFromStatistics() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 16)
        CheckResult testStatistics1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            String[] lines = Arrays.stream(output.split("\n"))
                    .filter(Predicate.not(String::isBlank))
                    .toArray(String[]::new);

            if (anyMissingKeywords(lines[0], "course", "details", "back", "quit")) {
                return CheckResult.wrong("When the \"statistics\" command is entered, your " +
                        "program must print: \"Type the name of a course to see details or 'back' " +
                        "to quit:\", but your output was: " + lines[0]);
            }

            if (lines.length < 7) {
                return CheckResult.wrong("Your program should print a header and 6 " +
                        "categories, but you printed only " + lines.length + " lines");
            }

            List<String> categories = List.of("Most popular: n/a", "Least popular: n/a",
                    "Highest activity: n/a", "Lowest activity: n/a", "Easiest course: n/a",
                    "Hardest course: n/a");
            for (int i = 1; i < lines.length; i++) {
                if (incorrectString(lines[i], categories.get(i - 1))) {
                    return CheckResult.wrong("Expected: " + categories.get(i - 1) +
                            ", but your output was " + lines[i]);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 17)
        CheckResult testStatistics2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            List<String> courses = List.of("Java", "DSA", "Databases", "Spring");
            for (String course : courses) {
                String output = main.execute(course);
                String[] lines = output.split("\n");
                if (lines.length < 2) {
                    return CheckResult.wrong("Expected 2 lines, but your output was only " + lines.length + " lines.");
                }

                if (incorrectString(lines[0], course.toLowerCase())) {
                    return CheckResult.wrong("Your first line should be " + course + ", but your output was " + lines[0]);
                }

                if (anyMissingKeywords(lines[1], "id", "points", "completed")) {
                    return CheckResult.wrong("Your second line should be \"id\tpoints\tcompleted\", " +
                            "but your output was " + lines[1]);
                }
            }

            List<String> unknown = Arrays.stream(getUnknownCommands())
                    .filter(str -> courses.stream().noneMatch(it -> it.trim().equalsIgnoreCase(str)))
                    .collect(Collectors.toList());

            for (String course : unknown) {
                String output = main.execute(course);
                if (incorrectString(output, "unknown course")) {
                    return CheckResult.wrong("Expected output: \"Unknown course.\", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 18)
        CheckResult testStatistics3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            main.execute("back");
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            String output = main.execute("back");
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 19)
        CheckResult testCategories1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (String id : ids) {
                main.execute(String.format("%s 5 4 3 1", id));
            }

            main.execute("back");
            lines = expect(main.execute("statistics")).toContain().lines();

            if (anyMissingKeywords(lines.get(1), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected most popular: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(1));
            }

            if (!lines.get(2).toLowerCase().contains("n/a")) {
                return CheckResult.wrong("Expected least popular: n/a, " +
                        "but your output was: " + lines.get(2));
            }

            if (anyMissingKeywords(lines.get(3), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected top activity: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(3));
            }

            if (!lines.get(4).contains("n/a")) {
                return CheckResult.wrong("Expected lowest activity: n/a, " +
                        "but your output was: " + lines.get(4));
            }

            if (anyMissingKeywords(lines.get(5), "java")) {
                return CheckResult.wrong("Expected easiest course: Java, " +
                        "but your output was: " + lines.get(5));
            }

            if (anyMissingKeywords(lines.get(6), "Spring")) {
                return CheckResult.wrong("Expected hardest course: Spring, " +
                        "but your output was: " + lines.get(6));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 20)
        CheckResult testCategories2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 10 10 10 10", ids.get(0)));
            main.execute(String.format("%s 5 5 5 5", ids.get(1)));
            main.execute(String.format("%s 5 5 5 5", ids.get(2)));
            main.execute(String.format("%s 2 2 2 2", ids.get(3)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(6).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(6).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(6).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(6).lines();

            if (!linesJava.get(2).matches(".+\\s+10\\s+1\\.7\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(4).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(5).matches(".+\\s+2\\s+0\\.3\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(0)) ||
                    !linesJava.get(3).startsWith(ids.get(1)) && !linesJava.get(3).startsWith(ids.get(2)) ||
                    !linesJava.get(4).startsWith(ids.get(1)) && !linesJava.get(4).startsWith(ids.get(2)) ||
                    !linesJava.get(5).startsWith(ids.get(3)) ||
                    linesJava.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesJava.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+10\\s+2\\.5\\s?%.*") ||
                    !linesDsa.get(3).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(4).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(5).matches(".+\\s+2\\s+0\\.5\\s?%.*") ||
                    !linesDsa.get(2).startsWith(ids.get(0)) ||
                    !linesDsa.get(3).startsWith(ids.get(1)) && !linesDsa.get(3).startsWith(ids.get(2)) ||
                    !linesDsa.get(4).startsWith(ids.get(1)) && !linesDsa.get(4).startsWith(ids.get(2)) ||
                    !linesDsa.get(5).startsWith(ids.get(3)) ||
                    linesDsa.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDsa.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+10\\s+2\\.1\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(4).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) ||
                    !linesDb.get(3).startsWith(ids.get(1)) && !linesDb.get(3).startsWith(ids.get(2)) ||
                    !linesDb.get(4).startsWith(ids.get(1)) && !linesDb.get(4).startsWith(ids.get(2)) ||
                    !linesDb.get(5).startsWith(ids.get(3)) ||
                    linesDb.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDb.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+10\\s+1\\.8\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(4).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) ||
                    !linesSpring.get(3).startsWith(ids.get(1)) && !linesSpring.get(3).startsWith(ids.get(2)) ||
                    !linesSpring.get(4).startsWith(ids.get(1)) && !linesSpring.get(4).startsWith(ids.get(2)) ||
                    !linesSpring.get(5).startsWith(ids.get(3)) ||
                    linesSpring.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesSpring.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 21)
        CheckResult testCategories3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 8 7 7 5", ids.get(0)));
            main.execute(String.format("%s 7 6 9 7", ids.get(0)));
            main.execute(String.format("%s 6 5 5 0", ids.get(0)));
            main.execute(String.format("%s 8 0 8 6", ids.get(1)));
            main.execute(String.format("%s 7 0 0 0", ids.get(1)));
            main.execute(String.format("%s 9 0 0 5", ids.get(1)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(4).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(3).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(4).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(4).lines();

            if (!linesJava.get(2).matches(".+\\s+24\\s+4\\.0\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+21\\s+3\\.5\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(1)) || !linesJava.get(3).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+18\\s+4\\.5\\s?%.*") || !linesDsa.get(2).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+21\\s+4\\.4\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+8\\s+1\\.7\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) || !linesDb.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+12\\s+2\\.2\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+11\\s+2\\.0\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) || !linesSpring.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 22)
        CheckResult testNotification1() {
            TestedProgram main = new TestedProgram();
            main.start();

            List<String> output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified.\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 23)
        CheckResult testNotification2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 600 400 0 0", ids.get(0)));
            main.execute("back");

            List<String> output = expect(main.execute("notify")).toContain(7).lines();

            if (!output.get(0).toLowerCase().startsWith("to:") ||
                    !output.get(0).toLowerCase().contains("johnd@email.net") ||
                    !output.get(1).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(1), "learning", "progress") ||
                    anyMissingKeywords(output.get(2), "john", "doe", "accomplished") ||
                    !output.get(2).toLowerCase().contains("java") && !output.get(5).toLowerCase().contains("java")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our Java course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (!output.get(3).toLowerCase().startsWith("to:") ||
                    !output.get(3).toLowerCase().contains("johnd@email.net") ||
                    !output.get(4).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(4), "learning", "progress") ||
                    anyMissingKeywords(output.get(5), "john", "doe", "accomplished", "course") ||
                    !output.get(5).toLowerCase().contains("dsa") && !output.get(2).toLowerCase().contains("dsa")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our DSA course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (anyMissingKeywords(output.get(6).toLowerCase(), "total", "1", "notified")) {
                return CheckResult.wrong("Expected output was \"Total 1 student has been notified.\", but your output was: \n" +
                        String.join("\n", output));
            }

            if (output.stream().map(String::toLowerCase).anyMatch(str ->
                    str.contains("jane") || str.contains("spark") || str.contains("jspark@yahoo.com"))) {
                return CheckResult.wrong("Your notification should not mention Jane Spark");
            }

            output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        private boolean anyMissingKeywords(String output, String... keywords) {
            List<String> tokens = Arrays.asList(
                    output.trim().toLowerCase().split("\\W+")
            );

            return !tokens.containsAll(Arrays.stream(keywords)
                    .map(String::toLowerCase)
                    .collect(Collectors.toList()));
        }

        private boolean incorrectString(String output, String model) {
            String normalizedOutput = output.replaceAll("\\W+", "").toLowerCase();
            String normalizedModel = model.replaceAll("\\W+", "").toLowerCase();

            return !normalizedOutput.contains(normalizedModel);
        }

        private String[] getBlankInput() {
            return new String[]{"", "  ", "\t", " \t"};
        }

        private String[] getUnknownCommands() {
            return new String[]{"abc", "quit", "  brexit ", "exi  t", "?", "break",
                    "-exit", "Ctrl+C", "exit please", ":q", "java", "spring", "dsa", "databases"};
        }

        private String[] getCorrectCredentials() {
            return new String[]{"John Smith jsmith@hotmail.com", "Anny Doolittle anny.md@mail.edu",
                    "Jean-Claude O'Connor jcda123@google.net", "Mary Emelianenko 125367at@zzz90.z9",
                    "Al Owen u15da125@a1s2f4f7.a1c2c5s4", "Robert Jemison Van de Graaff robertvdgraaff@mit.edu",
                    "Ed Eden a1@a1.a1", "na'me s-u ii@ii.ii", "n'a me su aa-b'b ab@ab.ab", "nA me 1@1.1"};
        }

        private String[][] getIncorrectCredentials() {
            return new String[][]{
                    {"", "Incorrect credentials"}, {" \t", "Incorrect credentials."},
                    {"name surname", "Incorrect credentials."},
                    {"n surname email@email.xyz", "Incorrect first name."},
                    {"'name surname email@email.xyz", "Incorrect first name."},
                    {"-name surname email@email.xyz", "Incorrect first name."},
                    {"name- surname email@email.xyz", "Incorrect first name."},
                    {"name' surname email@email.xyz", "Incorrect first name."},
                    {"nam-'e surname email@email.xyz", "Incorrect first name."},
                    {"na'-me surname email@email.xyz", "Incorrect first name."},
                    {"na--me surname email@email.xyz", "Incorrect first name."},
                    {"na''me surname email@email.xyz", "Incorrect first name."},
                    {"námé surname email@email.xyz", "Incorrect first name."},
                    {"name s email@email.xyz", "Incorrect last name."},
                    {"name -surname email@email.xyz", "Incorrect last name."},
                    {"name 'surname email@email.xyz", "Incorrect last name."},
                    {"name surnam''e email@email.xyz", "Incorrect last name."},
                    {"name surn--ame email@email.xyz", "Incorrect last name."},
                    {"name s'-urname email@email.xyz", "Incorrect last name."},
                    {"name su-'rname email@email.xyz", "Incorrect last name."},
                    {"name surname- email@email.xyz", "Incorrect last name."},
                    {"name surname' email@email.xyz", "Incorrect last name."},
                    {"name surnámé email@email.xyz", "Incorrect last name."},
                    {"name surname emailemail.xyz", "Incorrect email."},
                    {"name surname email@emailxyz", "Incorrect email."},
                    {"name surname email@e@mail.xyz", "Incorrect email."},
            };
        }

        private String[] getIncorrectPoints() {
            return new String[]{"", "-1 1 1 1", "1 1 2 A", "1 1 1", "1 1 1 1 1"};
        }

        private String[] getCorrectPoints(int n) {
            return Stream.generate(String::new)
                    .limit(n)
                    .map(it -> String.format("%d %d %d %d", nextPoint(), nextPoint(), nextPoint(), nextPoint()))
                    .toArray(String[]::new);
        }

        private int nextPoint() {
            return rnd.nextInt(10) + 1;
        }

        private List<String> parseIds(List<String> lines) {
            try {
                return lines.stream()
                        .skip(1)
                        .map(String::trim)
                        .collect(Collectors.toList());
            } catch (Exception e) {
                throw new WrongAnswer("Error occurred while parsing your output " + e.getMessage());
            }
        }

        private List<String> generateNames(int n) {
            List<String> names = List.of("Shoshana Utica", "Marisa Firman", "Gwenette Anagnos", "Charlena Girardo",
                    "Alexina Belcher", "Karee Antoinetta", "Dolley Panther", "Elysha Quinlan", "Trixie Winer",
                    "Ricki Trovillion", "Amye Uriisa", "Hedwig Wally", "Gwenette Kironde", "Jermaine Naaman",
                    "Olga Rosanne", "Annecorinne Ause", "Aurie Dorisa", "Van Fawnia", "Carmella Campman",
                    "Francesca Francis", "Elwira Florrie", "Nonna Miko", "Natka Herculie", "Roxi Hett", "Brandise Hardan",
                    "Toby Bleier", "Dalia Gleeson", "Emelia Annnora", "Beatrisa Jegar", "Barbara-Anne Chicky",
                    "Ann Agnella", "Lebbie Alabaster", "Leola Whelan", "Starlin Griz", "Anjanette Uis", "Tasha Chem");

            List<String> selectedNames = new ArrayList<>(names);
            Collections.shuffle(selectedNames);
            return selectedNames.stream().limit(n).collect(Collectors.toList());
        }

        private List<String> generateEmails(int n) {
            return IntStream.rangeClosed(1, n).mapToObj(it -> "address" + it + "@mail.com").collect(Collectors.toList());
        }

        private List<String> getRandomCredentials(int n) {
            List<String> names = generateNames(n);
            List<String> emails = generateEmails(n);
            return IntStream.range(0, n)
                    .mapToObj(it -> String.format("%s %s", names.get(it), emails.get(it)))
                    .collect(Collectors.toList());
        }
    }
  learner_created: false
- name: src/tracker/command/Command.java
  visible: true
  text: |
    package tracker.command;

    public interface Command {
        void execute();
    }
  learner_created: true
- name: src/tracker/command/TrackerBackCommand.java
  visible: true
  text: |
    package tracker.command;

    public class TrackerBackCommand implements Command {

        @Override
        public void execute() {
            System.out.println("Enter 'exit' to exit the program.");
        }
    }
  learner_created: true
- name: src/tracker/util/TrackerUtil.java
  visible: true
  text: |
    package tracker.util;

    import tracker.model.Assignment;
    import tracker.model.Course;
    import tracker.model.Student;

    import java.util.List;
    import java.util.Map;
    import java.util.Scanner;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.stream.Collectors;

    public class TrackerUtil {

        public static final String JAVA = "Java";
        public static final String DSA = "DSA";
        public static final String DATABASES = "Databases";
        public static final String SPRING = "Spring";
        public static final long MAX_POINTS_JAVA = 600;
        public static final long MAX_POINTS_DSA = 400;
        public static final long MAX_POINTS_DATABASES = 480;
        public static final long MAX_POINTS_SPRING = 550;

        public static final List<String> BASE_COURSES = List.of(
                JAVA,
                DSA,
                DATABASES,
                SPRING
        );

        public static final double PERCENT = 100.0;
        public static final List<String> STATISTICS_ROWS_NAMES = List.of(
                "Most popular",
                "Least popular",
                "Highest activity",
                "Lowest activity",
                "Easiest course",
                "Hardest course"
        );


        public static String stringifyCourseList(List<String> courses) {
            StringBuilder sb;
            sb = new StringBuilder();
            for (int i = 0; i < courses.size(); i++) {
                sb.append(courses.get(i));
                if (i < courses.size() - 1) {
                    sb.append(", ");
                }
            }

            return sb.toString();
        }

        public static Map<String, Long> findEnrolledStudentPerCourse(Map<Long, Student> studentMap) {
            Map<String, Long> enrolledStudentPerCourse = new ConcurrentHashMap<>();

            if (studentMap.isEmpty()) {
                return Map.of();
            }

            BASE_COURSES.forEach(course -> {
                long enrollment = studentMap.values()
                        .stream()
                        .filter(student -> student.isEnrolled(course))
                        .count();

                enrolledStudentPerCourse.put(course, enrollment);
            });

            return enrolledStudentPerCourse;
        }

        public static Map<String, Double> findAverageGradPerAssignmentEachCourse(List<Assignment> assignments) {

            Map<String, Double> averageGradMap = new ConcurrentHashMap<>();
            BASE_COURSES.forEach(s -> {
                double avgGrad = assignments.stream()
                        .map(Assignment::getCourse)
                        .filter(course -> s.equals(course.getName()))
                        .map(Course::getPoints)
                        .collect(Collectors.averagingDouble(Long::doubleValue));

                if (avgGrad > 0) {
                    averageGradMap.put(s, avgGrad);
                }
            });

            return averageGradMap;
        }

        public static String printCoursePoints(Student student) {
            StringBuilder sb = new StringBuilder(String.format("%s points: ", student.getId()));
            student.getCourses().forEach((s, course) -> {
                String format = BASE_COURSES.get(3).equals(s) ? "%s=%d" : "%s=%d; ";
                sb.append(String.format(format, s, course.getPoints()));
            });
            return sb.toString();
        }

        public static long maxPoints(String name) {
            switch (name) {
                case JAVA:
                    return MAX_POINTS_JAVA;
                case DATABASES:
                    return MAX_POINTS_DATABASES;
                case DSA:
                    return MAX_POINTS_DSA;
                case SPRING:
                    return MAX_POINTS_SPRING;
                default:
                    return 0;
            }
        }

        public static String requestUserInput() {
            return new Scanner(System.in).nextLine();
        }

        public static void logInfoForIncorrectValue(String value) {
            System.out.printf("Incorrect %s.\n", value);
        }
    }
  learner_created: true
- name: src/tracker/model/Course.java
  visible: true
  text: |
    package tracker.model;

    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.RequiredArgsConstructor;
    import tracker.util.TrackerUtil;

    @Builder
    @Data
    @RequiredArgsConstructor
    @AllArgsConstructor
    public class Course {

        private String name;
        private long maxPoints;
        private long points;

        public Course(String name) {
            this.name = name;
            this.maxPoints = TrackerUtil.maxPoints(name);
        }

        public Course(String name, long points) {
            this(name);
            this.points = points;
        }

        public void updatePoints(long points) {
            this.points += points;
        }

        public boolean isEnrolled() {
            return points > 0;
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerFindCommand.java
  visible: true
  text: |
    package tracker.command;

    import tracker.Tracker;
    import tracker.model.Student;
    import tracker.util.TrackerUtil;

    public class TrackerFindCommand implements Command {

        @Override
        public void execute() {
            find();
        }

        private void find() {
            System.out.println("Enter an id or 'back' to return");
            while (true) {
                String input = TrackerUtil.requestUserInput();

                if ("back".equals(input)) {
                    return;
                }

                if (input.matches("\\d+")) {
                    Student student = Tracker.students.get(Long.parseLong(input));
                    if (student == null) {
                        System.out.printf("No student is found for id=%s\n", input);
                    } else {
                        System.out.println(TrackerUtil.printCoursePoints(student));
                    }
                }
            }
        }
    }
  learner_created: true
- name: src/tracker/Tracker.java
  visible: true
  text: |
    package tracker;

    import tracker.command.Command;
    import tracker.domain.CommandFactory;
    import tracker.model.Assignment;
    import tracker.model.Student;
    import tracker.util.TrackerUtil;

    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;

    public class Tracker {

        private static final Tracker INSTANCE = new Tracker();

        public static Map<Long, Student> students = new HashMap<>();
        public static List<Assignment> assignments = new ArrayList<>();

        public static Tracker getInstance() {
            return INSTANCE;
        }

        public void start() {
            System.out.println("Learning Progress Tracker");
            String input = null;

            while(!"exit".equals(input)) {
                input = TrackerUtil.requestUserInput().trim();

                if (input.isEmpty()) {
                    System.out.println("No input.");
                } else {
                    Command command = CommandFactory.getCommand(input);
                    if (command != null) {
                        command.execute();
                    }
                }
            }
        }
    }
  learner_created: true
- name: src/tracker/search/SearchStrategy.java
  visible: true
  text: |
    package tracker.search;

    import java.util.List;

    public interface SearchStrategy {

        List<String> findMax();
        List<String> findMin();
    }
  learner_created: true
- name: src/tracker/model/Student.java
  visible: true
  text: |
    package tracker.model;

    import lombok.*;
    import tracker.util.TrackerUtil;
    import tracker.util.TrackerValidator;

    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.Map;

    @Builder
    @Data
    public class Student {

        private long id;
        private String firstname;
        private String lastname;
        private String email;
        private Map<String, Course> courses;

        public boolean hasValidFirstname() {
            return TrackerValidator.validate(firstname);
        }

        public boolean isValid() {
            return hasValidFirstname() & hasValidLastname() & hasValidEmail();
        }

        public boolean hasValidEmail() {
            return TrackerValidator.isValidEmail(email);
        }

        public boolean hasValidLastname() {
            return TrackerValidator.isValidLastname(lastname);
        }

        public void updateCourse(String name, long points) {

            if (courses.containsKey(name)) {
                Course course = courses.get(name);
                course.updatePoints(points);
                courses.replace(name, course);
            } else {
                courses.put(name, new Course(name, points));
            }
        }

        public boolean isEnrolled(String course) {
            return !courses.isEmpty() && courses.get(course).isEnrolled();
        }

        public Long sumPoints(String courseName) {
            return courses.get(courseName).getPoints();
        }

        public double progress(String courseName) {
            final Course course = courses.get(courseName);
            return new BigDecimal((double) sumPoints(courseName) * TrackerUtil.PERCENT / course.getMaxPoints())
                    .setScale(1, RoundingMode.HALF_UP)
                    .doubleValue();
        }
    }
  learner_created: true
- name: src/tracker/domain/NumberGenerator.java
  visible: true
  text: |
    package tracker.domain;

    public class NumberGenerator {

        private static final NumberGenerator INSTANCE = new NumberGenerator();

        private int value = 9999;

        public static NumberGenerator getInstance() {
            return INSTANCE;
        }

        public int next() {
            return ++value;
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerAddPointCommand.java
  visible: true
  text: |
    package tracker.command;

    import tracker.Tracker;
    import tracker.model.Assignment;
    import tracker.model.Course;
    import tracker.model.Student;
    import tracker.util.TrackerUtil;
    import tracker.util.TrackerValidator;

    import java.util.Arrays;
    import java.util.List;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;

    import static tracker.util.TrackerUtil.BASE_COURSES;

    public class TrackerAddPointCommand implements Command {

        @Override
        public void execute() {
            addPoints();
        }

        private void addPoints() {
            System.out.println("Enter an id and points or 'back' to return:");

            while (true) {
                String input = TrackerUtil.requestUserInput();

                if ("back".equals(input)) {
                    return;
                }

                String[] data = input.split("\\s+");
                String studentId = data[0];

                if (!studentId.matches("\\d+")) {
                    System.out.printf("No student is found for id=%s.\n", studentId);
                } else if (!TrackerValidator.valid(input)) {
                    System.out.println("Incorrect points format");
                } else {
                    List<Long> records = Arrays.stream(data).map(Long::parseLong).collect(Collectors.toList());
                    final Long id = Long.parseLong(studentId);
                    Student student = Tracker.students.get(id);
                    if (student == null) {
                        System.out.printf("No student is found for id=%s.\n", studentId);
                    } else {
                        update(records.subList(1, records.size()), student);
                        System.out.println("Points updated.");
                        Tracker.students.replace(id, student);
                    }
                }
            }
        }

        private void update(List<Long> records, Student student) {
            IntStream.range(0, records.size())
                    .forEach(i -> {
                        String name = BASE_COURSES.get(i);
                        Long points = records.get(i);
                        student.updateCourse(name, points);
                        if (points > 0) {
                            Assignment assignment = new Assignment(student.getId(), new Course(name, points));
                            Tracker.assignments.add(assignment);
                        }
                    });
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerExitCommand.java
  visible: true
  text: |
    package tracker.command;

    public class TrackerExitCommand implements Command {

        @Override
        public void execute() {
            System.out.println("Bye!");
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerAddStudentCommand.java
  visible: true
  text: |
    package tracker.command;

    import tracker.Tracker;
    import tracker.domain.NumberGenerator;
    import tracker.model.Student;
    import tracker.util.TrackerUtil;

    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.List;
    import java.util.stream.IntStream;

    public class TrackerAddStudentCommand implements Command {

        @Override
        public void execute() {
            add();
        }

        public void add() {
            System.out.println("Enter student credentials or 'back' to return:");
            String input;
            while (true) {
                input = TrackerUtil.requestUserInput();
                List<String> credentials = Arrays.asList(input.split("\\s+"));
                final int size = credentials.size();

                if (credentials.contains("back")) {
                    System.out.printf("Total %s students have been added.\n", Tracker.students.size());
                    return;
                } else if (size <= 2) {
                    System.out.println("Incorrect credentials.");
                } else {
                    String firstname = credentials.get(0);
                    String email = credentials.get(size - 1).trim();

                    if (exist(email)) {
                        System.out.println("This email is already taken.");
                    } else {
                        StringBuilder lastname = new StringBuilder();
                        IntStream.range(1, size - 1)
                                .forEach(i -> lastname.append(credentials.get(i)).append(" "));

                        Student student = Student.builder()
                                .id(NumberGenerator.getInstance().next())
                                .firstname(firstname)
                                .lastname(lastname.toString().trim())
                                .email(email)
                                .courses(new HashMap<>())
                                .build();

                        validate(student);
                    }
                }
            }
        }

        private void validate(Student student) {
            if (!student.isValid()) {
                if (!student.hasValidFirstname()) {
                    TrackerUtil.logInfoForIncorrectValue("first name");
                } else if (!student.hasValidLastname()) {
                    TrackerUtil.logInfoForIncorrectValue("last name");
                } else {
                    TrackerUtil.logInfoForIncorrectValue("email");
                }
            } else {
                Tracker.students.put(student.getId(), student);
                System.out.println("The student has been added.");
            }
        }

        private boolean exist(String email) {
            return Tracker.students.values()
                    .stream()
                    .anyMatch(student -> email.equals(student.getEmail()));
        }
    }
  learner_created: true
- name: src/tracker/model/Assignment.java
  visible: true
  text: |
    package tracker.model;

    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;

    @Data
    @Builder
    @AllArgsConstructor
    public class Assignment {

        private Long studentId;
        private Course course;
    }
  learner_created: true
- name: src/tracker/command/TrackerListCommand.java
  visible: true
  text: |
    package tracker.command;

    import tracker.Tracker;

    public class TrackerListCommand implements Command {

        @Override
        public void execute() {
            list();
        }

        public void list() {
            if (Tracker.students.isEmpty()) {
                System.out.println("No students found");
                return;
            }

            System.out.println("Students:");
            Tracker.students.keySet().forEach(System.out::println);
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerStatisticsCommand.java
  visible: true
  text: |
    package tracker.command;

    import tracker.Tracker;
    import tracker.model.Assignment;
    import tracker.model.Student;
    import tracker.search.CourseGroupSearchContext;
    import tracker.search.CourseStrengthSearchContext;
    import tracker.search.Finder;

    import java.util.*;

    import static java.util.stream.Collectors.counting;
    import static java.util.stream.Collectors.groupingBy;
    import static tracker.util.TrackerUtil.*;

    public class TrackerStatisticsCommand implements Command {

        private final Finder finder = new Finder();
        private final CourseGroupSearchContext searchContext = new CourseGroupSearchContext();
        private final CourseStrengthSearchContext strengthSearchContext = new CourseStrengthSearchContext();
        private final Map<Long, Student> studentMap = Tracker.students;
        private final List<Assignment> assignments = Tracker.assignments;

        private final Map<String, Long> courseSubmission;

        {
            this.courseSubmission = assignments
                    .stream()
                    .collect(groupingBy(assignment -> assignment.getCourse().getName(), counting()));
        }

        @Override
        public void execute() {
            stat();
        }

        public void stat() {
            System.out.println("Type the name of a course to see details or 'back' to quit");
            STATISTICS_ROWS_NAMES.forEach(s -> System.out.printf("%s: %s\n", s, findCourseByCategory(s)));
            while (true) {
                String input = new Scanner(System.in).nextLine();
                if ("back".equals(input)) {
                    return;
                } else if (BASE_COURSES.stream().noneMatch(s -> s.equalsIgnoreCase(input))) {
                    System.out.println("Unknown course.");
                } else {
                    String courseName = "dsa".equals(input) ? input.toUpperCase() : input.substring(0, 1).toUpperCase() + input.substring(1);
                    showCourseDetails(courseName);
                }
            }
        }

        public String findCourseByCategory(String category) {

            String stringBuilder;
            List<String> courses;

            switch (category) {
                case "Most popular":
                    stringBuilder = stringifyCourseList(findMostPopularCourses());
                    break;
                case "Least popular":
                    courses = findLeastPopularCourse();
                    courses.removeAll(findMostPopularCourses());
                    stringBuilder = stringifyCourseList(courses);
                    break;
                case "Highest activity":
                    stringBuilder = stringifyCourseList(findCourseWithHighestActivity());
                    break;
                case "Lowest activity":
                    courses = findCourseWithLowestActivity();
                    courses.removeAll(findCourseWithHighestActivity());
                    stringBuilder = stringifyCourseList(courses);
                    break;
                case "Easiest course":
                    stringBuilder = stringifyCourseList(findEasiestCourse());
                    break;
                case "Hardest course":
                    courses = findHardestCourse();
                    courses.removeAll(findEasiestCourse());
                    stringBuilder = stringifyCourseList(courses);
                    break;
                default:
                    throw new IllegalStateException("Unexpected value: " + category);
            }

            return stringBuilder.isEmpty() ? "n/a" : stringBuilder;
        }


        public List<String> findMostPopularCourses() {
            return finder.setStrategy(searchContext.setMap(findEnrolledStudentPerCourse(studentMap)))
                    .findMax();
        }

        public List<String> findLeastPopularCourse() {
            return finder.setStrategy(searchContext.setMap(findEnrolledStudentPerCourse(studentMap)))
                    .findMin();
        }

        public List<String> findHardestCourse() {
            return finder.setStrategy(strengthSearchContext
                            .setMap(findAverageGradPerAssignmentEachCourse(assignments)))
                    .findMin();
        }

        public List<String> findEasiestCourse() {
            return finder.setStrategy(strengthSearchContext
                            .setMap(findAverageGradPerAssignmentEachCourse(assignments)))
                    .findMax();
        }

        public List<String> findCourseWithHighestActivity() {
            if (courseSubmission.values().stream().allMatch((aLong -> aLong == 0))) {
                return Collections.emptyList();
            }
            return finder.setStrategy(searchContext
                            .setMap(courseSubmission))
                    .findMax();
        }


        public List<String> findCourseWithLowestActivity() {
            if (courseSubmission.values().stream().allMatch((aLong -> aLong == 0))) {
                return Collections.emptyList();
            }
            return finder.setStrategy(searchContext
                            .setMap(courseSubmission))
                    .findMin();
        }

        public void showCourseDetails(String courseName) {
            System.out.println(courseName);
            System.out.println("id\tpoints\tcompleted");
            StringBuilder stringBuilder = new StringBuilder();

            Tracker.students.values()
                    .stream()
                    .filter(student -> student.isEnrolled(courseName))
                    .sorted(Comparator.comparing(student -> student.sumPoints(courseName), Comparator.reverseOrder()))
                    .forEachOrdered(student -> stringBuilder.append(student.getId()).append("\t")
                            .append(student.sumPoints(courseName)).append("\t")
                            .append(student.progress(courseName)).append("%\n"));

            if (!stringBuilder.toString().isEmpty()) {
                System.out.print(stringBuilder);
            }
        }
    }
  learner_created: true
- name: src/tracker/domain/CommandFactory.java
  visible: true
  text: |
    package tracker.domain;

    import tracker.command.*;

    public class CommandFactory {

        public static Command getCommand(String input) {

            switch (input) {
                case "back":
                    return new TrackerBackCommand();
                case "add students":
                    return new TrackerAddStudentCommand();
                case "list":
                    return new TrackerListCommand();
                case "add points":
                    return new TrackerAddPointCommand();
                case "find":
                    return new TrackerFindCommand();
                case "statistics":
                    return new TrackerStatisticsCommand();
                case "exit":
                    return new TrackerExitCommand();
                default:
                    System.out.println("Error: unknown command!");
                    break;
            }

            return null;
        }
    }
  learner_created: true
- name: src/tracker/util/TrackerValidator.java
  visible: true
  text: |
    package tracker.util;

    import java.util.Arrays;
    import java.util.List;

    public class TrackerValidator {

        public static final String NAME_REGEX = "^[A-Za-z]+[-']?[A-Za-z]+";
        public static final String LASTNAME_REGEX = "[A-Za-z ]+([-' ][A-Za-z ])*[-' ]?[A-Za-z]+";
        public static final String EMAIL_REGEX = "[\\w.]+@\\w+\\.[a-z\\d]+";

        public static boolean validate(String firstname) {
            return firstname.matches(NAME_REGEX);
        }

        public static boolean isValidLastname(String lastname) {
            return lastname.matches(LASTNAME_REGEX);
        }

        public static boolean isValidEmail(String email) {
            return email.matches(EMAIL_REGEX);
        }

        public static boolean valid(String input) {
            List<String> data = Arrays.asList(input.split("\\s+"));
            return data.size() == 5 && allNumeric(data);
        }

        private static boolean allNumeric(List<String> data) {
            return data.stream().allMatch(s -> s.matches("\\d+"));
        }
    }
  learner_created: true
- name: src/tracker/command/TrackerNotifyCommand.java
  visible: true
  learner_created: true
- name: src/tracker/search/SearchContext.java
  visible: true
  text: |
    package tracker.search;

    import java.util.List;

    public class Finder {

        private SearchStrategy strategy;

        public Finder setStrategy(SearchStrategy strategy) {
            this.strategy = strategy;
            return this;
        }

        public List<String> findMax() {
            return strategy.findMax();
        }

        public List<String> findMin() {
            return strategy.findMin();
        }
    }
  learner_created: true
- name: src/tracker/search/CourseStrengthSearch.java
  visible: true
  text: |
    package tracker.search;

    import java.util.Collections;
    import java.util.List;
    import java.util.Map;
    import java.util.Objects;
    import java.util.stream.Collectors;

    public class CourseStrengthSearchContext implements SearchStrategy {

        private Map<String, Double> map;

        public CourseStrengthSearchContext setMap(Map<String, Double> map) {
            this.map = map;
            return this;
        }

        @Override
        public List<String> findMax() {
            return map.entrySet()
                    .stream()
                    .filter(entry -> Objects.equals(entry.getValue(), Collections.max(map.values())))
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList());
        }

        @Override
        public List<String> findMin() {
            return map.entrySet()
                    .stream()
                    .filter(entry -> Objects.equals(entry.getValue(), Collections.min(map.values())))
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList());
        }
    }
  learner_created: true
- name: src/tracker/search/CourseGroupSearch.java
  visible: true
  text: |
    package tracker.search;

    import java.util.Collections;
    import java.util.List;
    import java.util.Map;
    import java.util.Objects;
    import java.util.stream.Collectors;

    public class CourseGroupSearchContext implements SearchStrategy {

        private Map<String, Long> map;

        public CourseGroupSearchContext setMap(Map<String, Long> map) {
            this.map = map;
            return this;
        }

        @Override
        public List<String> findMax() {
            return map.entrySet()
                    .stream()
                    .filter(entry -> Objects.equals(entry.getValue(), Collections.max(map.values())))
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList());
        }

        @Override
        public List<String> findMin() {
            return map.entrySet()
                    .stream().filter(entry -> Objects.equals(entry.getValue(), Collections.min(map.values())))
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList());
        }
    }
  learner_created: true
- name: src/tracker/domain/TrackerAction.java
  visible: true
  learner_created: true
- name: src/tracker/domain/CourseType.java
  visible: true
  learner_created: true
- name: src/tracker/domain/Category.java
  visible: true
  learner_created: true
- name: src/tracker/command/Statistic.java
  visible: true
  learner_created: true
- name: src/tracker/domain/StudentFactory.java
  visible: true
  learner_created: true
- name: src/tracker/domain/NotificationService.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/14400#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Thu, 12 Jan 2023 22:19:02 UTC
record: -1
